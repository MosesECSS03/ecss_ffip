const { MongoClient, ObjectId        this.isConnected = false;
        this.connectionPromise = null;
        this.connectionLock = false;
        this.silentMode = options.silentMode || false;
        this.lastConnectionAttempt = 0;
        this.connectionCooldown = 500; // Ultra-fast 0.5 second cooldown
        this.healthCheckInterval = null;
        this.isHealthy = true;
        
        // SMART CONNECTION MONITORING for unlimited scale
        this.activeConnections = 0;
        this.maxRecommendedConnections = this._getRecommendedLimit();
        this.connectionWarningThreshold = Math.floor(this.maxRecommendedConnections * 0.8);
        this.performanceMetrics = {
            totalRequests: 0,
            successfulRequests: 0,
            averageResponseTime: 0,
            lastPerformanceCheck: Date.now()
        };
        
        // Log instance creation
        if (!this.silentMode) {
            console.log(`🚀 SMART-UNLIMITED Database instance: ${this.instanceId} (UNLIMITED + SAFEGUARDS)`);
            console.log(`📊 Monitoring threshold: ${this.maxRecommendedConnections} connections`);
        }
    }

    // Get recommended connection limit based on MongoDB Atlas tier
    _getRecommendedLimit() {
        // These are MongoDB Atlas connection limits by tier
        const atlasLimits = {
            'M0': 500,      // Free tier
            'M2': 1500,     // Shared tier
            'M5': 1500,     // Shared tier
            'M10': 3000,    // Dedicated small
            'M20': 5000,    // Dedicated medium
            'M30': 5000,    // Dedicated large
            'M40': 10000,   // Dedicated XL
            'M50': 10000,   // Dedicated XXL
            'M60': 15000,   // Dedicated XXXL
        };
        
        // Default to M10 equivalent (conservative estimate)
        // In production, you could detect this from MongoDB Atlas API
        return 3000;('mongodb');

const uri = 'mongodb+srv://moseslee:Mlxy6695@ecss-course.hejib.mongodb.net/?retryWrites=true&w=majority&appName=ECSS-Course';

class DatabaseConnectivity {
    constructor(options = {}) {
        this.instanceId = options.instanceId || `db_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
        this.client = new MongoClient(uri, {
            maxPoolSize: options.maxPoolSize || 0,         // UNLIMITED connections for maximum throughput
            minPoolSize: options.minPoolSize || 10,        // More ready connections for instant response
            maxIdleTimeMS: 300000,  // 5 minutes - keep connections alive longer
            serverSelectionTimeoutMS: 1500,  // Ultra-fast server selection
            socketTimeoutMS: 15000, // Faster socket timeout for quick failures
            connectTimeoutMS: 3000, // Lightning-fast connection timeout
            heartbeatFrequencyMS: 3000, // Frequent heartbeats for optimal health
            retryWrites: true,
            retryReads: true,
            readPreference: 'primary', // Fastest read preference for QR scanning
            writeConcern: { w: 'majority', j: false, wtimeout: 1000 }, // Ultra-fast writes
            // MAXIMUM PERFORMANCE optimizations
            maxConnecting: 20,      // Allow many simultaneous connections
            waitQueueTimeoutMS: 1000, // Ultra-fast queue timeout
            compressors: ['snappy', 'zlib'], // Best compression for speed
            zlibCompressionLevel: 1, // Fast compression level
            // Additional speed optimizations
            bufferMaxEntries: 0,    // No buffering for instant operations
            useUnifiedTopology: true,
            monitorCommands: false, // Disable monitoring for speed
        });
        this.isConnected = false;
        this.connectionPromise = null;
        this.connectionLock = false;
        this.silentMode = options.silentMode || false;
        this.lastConnectionAttempt = 0;
        this.connectionCooldown = 500; // Ultra-fast 0.5 second cooldown
        this.healthCheckInterval = null;
        this.isHealthy = true;
        
        // Log instance creation
        if (!this.silentMode) {
            console.log(`� ULTRA-OPTIMAL Database instance: ${this.instanceId} (UNLIMITED + SEAMLESS)`);
        }
    }

    async initialize() {
        // Lightning-fast health check if already connected
        if (this.isConnected && this.isHealthy) {
            try {
                // Super-quick ping with minimal timeout
                await this.client.db('admin').command({ ping: 1 }, { maxTimeMS: 500 });
                return;
            } catch (error) {
                // Silent seamless reconnect
                this.isConnected = false;
                this.isHealthy = false;
            }
        }

        // Ultra-minimal cooldown for maximum speed
        const now = Date.now();
        if (now - this.lastConnectionAttempt < this.connectionCooldown) {
            // Skip cooldown error for seamless experience
            if (this.connectionPromise) {
                return this.connectionPromise;
            }
        }

        // If connection is in progress, wait for it
        if (this.connectionPromise) {
            return this.connectionPromise;
        }

        // Start new connection with optimized retry logic
        this.connectionPromise = this._connectWithRetry();
        return this.connectionPromise;
    }

    async _connectWithRetry() {
        let retryCount = 0;
        const maxRetries = 3; // Optimized retry count for speed
        this.lastConnectionAttempt = Date.now();
        
        while (retryCount < maxRetries) {
            try {
                if (!this.silentMode) {
                    console.log(`⚡ Ultra-fast connection (${retryCount + 1}/${maxRetries}) - SEAMLESS MODE`);
                }
                
                if (!this.isConnected) {
                    // Lightning-fast connection with minimal timeout
                    await Promise.race([
                        this.client.connect(),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Connection timeout after 3 seconds')), 3000)
                        )
                    ]);
                    
                    // Instant health check
                    await Promise.race([
                        this.client.db('admin').command({ ping: 1 }),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Ping timeout after 1 second')), 1000)
                        )
                    ]);
                    
                    this.isConnected = true;
                    this.isHealthy = true;
                    if (!this.silentMode) {
                        console.log('⚡ SEAMLESS DATABASE READY - ULTRA-OPTIMAL MODE ACTIVE');
                    }
                    
                    // Start optimized health monitoring
                    this._startHealthCheck();
                }
                
                this.connectionPromise = null;
                return;
                
            } catch (error) {
                retryCount++;
                this.isConnected = false;
                this.isHealthy = false;
                
                if (retryCount < maxRetries) {
                    // ABSOLUTELY INSTANT RETRY - Zero delay for seamless experience
                    if (!this.silentMode) {
                        console.log(`⚡ Seamless retry ${retryCount}...`);
                    }
                    // Continue immediately - maximum seamless speed!
                } else {
                    this.connectionPromise = null;
                    if (this.silentMode) {
                        console.warn(`Database connection failed after ${maxRetries} attempts. Operating in offline mode.`);
                        return;
                    }
                    throw new Error(`Failed to connect to database after ${maxRetries} attempts: ${error.message}`);
                }
            }
        }
    }

    _startHealthCheck() {
        // Clear any existing health check
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
        }
        
        // Optimized health monitoring for seamless performance
        this.healthCheckInterval = setInterval(async () => {
            try {
                if (this.isConnected) {
                    await this.client.db('admin').command({ ping: 1 }, { maxTimeMS: 500 });
                    this.isHealthy = true;
                }
            } catch (error) {
                // Silent health check failures for seamless experience
                this.isHealthy = false;
                this.isConnected = false;
            }
        }, 15000); // Check every 15 seconds for optimal balance
    }

    _stopHealthCheck() {
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
        }
    }

    async insertDocument(databaseName, collectionName, document) {
        let retryCount = 0;
        const maxRetries = 3; // Optimized retry count for seamless speed
        
        while (retryCount < maxRetries) {
            try {
                await this.initialize();
                
                // If not connected and in silent mode, return gracefully
                if (!this.isConnected && this.silentMode) {
                    return {
                        success: false,
                        error: 'Database not available',
                        offline: true
                    };
                }
                
                const db = this.client.db(databaseName);
                const collection = db.collection(collectionName);
                
                // MAXIMUM SPEED insert operation
                const result = await Promise.race([
                    collection.insertOne(document, { wtimeout: 1000 }), // Lightning-fast write timeout
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Insert operation timeout')), 1500) // Ultra-minimal timeout
                    )
                ]);
                
                return {
                    success: true,
                    insertedId: result.insertedId,
                    message: 'Document inserted successfully'
                };
            } catch (error) {
                retryCount++;
                
                // Only retry for connection errors
                if (this._isConnectionError(error) && retryCount < maxRetries) {
                    // SEAMLESS INSTANT RETRY - Zero delay
                    continue;
                }
                
                return {
                    success: false,
                    error: error.message
                };
            }
        }
    }

    async getDocument(databaseName, collectionName, query) {
        let retryCount = 0;
        const maxRetries = 3; // Optimized for seamless QR scanning
        
        while (retryCount < maxRetries) {
            try {
                await this.initialize();
                
                // If not connected and in silent mode, return gracefully
                if (!this.isConnected && this.silentMode) {
                    return {
                        success: false,
                        error: 'Database not available',
                        data: null,
                        offline: true
                    };
                }
                
                const db = this.client.db(databaseName);
                const collection = db.collection(collectionName);
                
                // MAXIMUM SPEED query operation for QR scanning
                const document = await Promise.race([
                    collection.findOne(query, { maxTimeMS: 1000 }), // Lightning-fast query timeout
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Query operation timeout')), 1200) // Minimal overall timeout
                    )
                ]);
                
                if (!document) {
                    return {
                        success: false,
                        message: 'No document found matching the query',
                        data: null
                    };
                }
                return {
                    success: true,
                    message: 'Document retrieved successfully',
                    data: document
                };
            } catch (error) {
                retryCount++;
                
                // Only retry for connection errors, not query errors
                if (this._isConnectionError(error) && retryCount < maxRetries) {
                    // SEAMLESS INSTANT RETRY - Zero delay for maximum speed
                    continue;
                }
                
                // For non-connection errors (like "document not found"), return immediately
                return {
                    success: false,
                    error: error.message
                };
            }
        }
    }

    _isConnectionError(error) {
        // Only treat actual connection/network errors as connection issues
        // Don't treat application-level errors (like validation failures) as connection errors
        return error.name === 'MongoServerSelectionError' || 
               error.name === 'MongoNetworkTimeoutError' ||
               error.name === 'MongoTimeoutError' ||
               (error.message && error.message.includes('connection')) ||
               (error.message && error.message.includes('server selection timeout')) ||
               (error.message && error.message.includes('Connection timeout'));
    }

    async findDocuments(databaseName, collectionName, query = {}) {
        let retryCount = 0;
        const maxRetries = 3; // Optimized retry count for speed
        
        while (retryCount < maxRetries) {
            try {
                await this.initialize();
                
                // If not connected and in silent mode, return gracefully
                if (!this.isConnected && this.silentMode) {
                    return {
                        success: false,
                        error: 'Database not available',
                        data: [],
                        offline: true
                    };
                }
                
                const db = this.client.db(databaseName);
                const collection = db.collection(collectionName);
                
                // MAXIMUM SPEED find operation
                const documents = await Promise.race([
                    collection.find(query).toArray(),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Find operation timeout')), 2500) // Optimized timeout
                    )
                ]);
                
                return {
                    success: true,
                    message: `Retrieved ${documents.length} documents successfully`,
                    data: documents
                };
            } catch (error) {
                retryCount++;
                
                // Only retry for connection errors
                if (this._isConnectionError(error) && retryCount < maxRetries) {
                    // SEAMLESS INSTANT RETRY - Zero delay
                    continue;
                }
                
                return {
                    success: false,
                    error: error.message,
                    data: []
                };
            }
        }
    }

    async updateDocument(databaseName, collectionName, query, update) {
        let retryCount = 0;
        const maxRetries = 3; // Optimized retry count for seamless speed
        
        while (retryCount < maxRetries) {
            try {
                await this.initialize();
                
                // If not connected and in silent mode, return gracefully
                if (!this.isConnected && this.silentMode) {
                    return {
                        success: false,
                        error: 'Database not available',
                        offline: true
                    };
                }
                
                const db = this.client.db(databaseName);
                const collection = db.collection(collectionName);
                
                // MAXIMUM SPEED update operation
                const result = await Promise.race([
                    collection.updateOne(query, update, { wtimeout: 1000 }), // Lightning-fast write timeout
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Update operation timeout')), 1500) // Minimal overall timeout
                    )
                ]);
                
                if (result.modifiedCount === 1) {
                    return {
                        success: true,
                        message: 'Document updated successfully',
                        data: result
                    };
                } else if (result.matchedCount === 1) {
                    return {
                        success: true,
                        message: 'No changes made to the document',
                        data: result
                    };
                } else {
                    return {
                        success: false,
                        message: 'No document found to update',
                        data: null
                    };
                }
            } catch (error) {
                retryCount++;
                
                // Only retry for connection errors
                if (this._isConnectionError(error) && retryCount < maxRetries) {
                    // SEAMLESS INSTANT RETRY - Zero delay
                    continue;
                }
                
                return {
                    success: false,
                    error: error.message
                };
            }
        }
    }

    async disconnect() {
        try {
            this._stopHealthCheck();
            await this.client.close();
            this.isConnected = false;
            this.isHealthy = false;
            this.connectionPromise = null;
            if (!this.silentMode) {
                console.log('🔌 Database disconnected successfully');
            }
        } catch (error) {
            if (!this.silentMode) {
                console.error('❌ Error disconnecting from database:', error);
            }
            throw error;
        }
    }

    // Static method to create multiple parallel database instances
    static createParallelInstances(count = 3, options = {}) {
        const instances = [];
        
        for (let i = 0; i < count; i++) {
            const instanceOptions = {
                ...options,
                instanceId: `unlimited_${i + 1}_${Date.now()}`,
                maxPoolSize: 0,  // UNLIMITED connections for each instance
                minPoolSize: Math.max(Math.floor(20 / count), 3), // Distribute minimum connections
                silentMode: options.silentMode || false
            };
            
            instances.push(new DatabaseConnectivity(instanceOptions));
        }
        
        console.log(`🔗 Created ${count} parallel database instances with UNLIMITED CONNECTIONS each! 🚀`);
        return instances;
    }

    // Static method to get a load-balanced instance from parallel instances
    static getLoadBalancedInstance(instances) {
        if (!instances || instances.length === 0) {
            throw new Error('No database instances available');
        }
        
        // Simple round-robin load balancing
        if (!this.currentInstanceIndex) {
            this.currentInstanceIndex = 0;
        }
        
        const instance = instances[this.currentInstanceIndex];
        this.currentInstanceIndex = (this.currentInstanceIndex + 1) % instances.length;
        
        return instance;
    }

    // Get instance information
    getInstanceInfo() {
        return {
            instanceId: this.instanceId,
            isConnected: this.isConnected,
            isHealthy: this.isHealthy,
            poolSize: this.client.options.maxPoolSize,
            minPoolSize: this.client.options.minPoolSize
        };
    }
}

module.exports = DatabaseConnectivity;